#include <stdio.h>

int main (void) {
  int v1 = 10, v2 = 20;
  /* 
     変数名の前に * （アスタリスク）をつけて宣言されたものは，
     ポインタ変数になります．
     この例では，「int型の変数のポインタ変数である」ptrを宣言
     しています．この表現は長いので，単純に「int型のポインタ」
     という風に呼ぶこともあります．
     通常の変数と同じように，宣言の段階で初期化がされていなければ
     その内容は不定です．
  */
  int *ptr;
  
  /*
     ポインタ変数にも，通常の変数と同様に値を代入できます．
     ただし，通常の変数の様に数値やASCIIコードを代入したりはしません．
     ここでは &v1 というものを代入しています．
     &v1 は，「変数 v1 の場所」を表します．
     この代入を行うことで， 「ptr が変数 v1 を参照している」状態に
     なります．
  */
  ptr = &v1;
  /* 
     次のprintf関数の呼び出し文は，v1，v2，ptrという3つの変数の状況を
     確認するために呼び出しています．
     まずはじめに "v1@%p" という書式文字列で， &v1 の中身を表示しています．
     %p という出力変換指定子は，普段あまり使いませんが，変数の場所を
     表すアドレスという数値を16進数で表示するためのものです．
     これに，&v1 を与えることで，v1 の場所（正確にはアドレス）を表示する
     ことができます．
     次に "%d" で v1 を表示しています．これは通常通り v1 に代入されている
     値を表示するものです．
     "v2@%p = %d" の部分は，v2 に対して同様のことを行っていますので，
     v2 の場所（アドレス）と，v2 に代入されている値を表示します．
     最後に "ptr = %p" に対して，ptr を与えています．
     ptr はポインタ変数で，その中身はいずれかの変数の場所（アドレス）が
     入っていますから，%p にそのまま与えることで，そのアドレスを表示する
     ことができます．
   */
  /* 
     v1 には 10，v2 には 20 が入っていて，ptr には v1 の場所が入っています．
  */
  printf ("v1@%p = %d, v2@%p = %d, ptr = %p\n", &v1, v1, &v2, v2, ptr);

  /*
     次の代入文は特殊です．
     *ptr のように，ポインタ変数の前に * （アスタリスク）ををつけると，
     「ptr が参照している変数の中身にアクセスする」ことができます．
     つまり，この代入文では， 「ptr が参照している変数（v1）に対して，
     100 を代入する」という処理が行われます．
   */
  *ptr = 100;
  /* 
     v1 の中身が 100 に変わっていることを確認しましょう．
  */
  printf ("v1@%p = %d, v2@%p = %d, ptr = %p\n", &v1, v1, &v2, v2, ptr);

  /*
     次のように，ポインタ変数に別の変数の場所（アドレス）を代入することで，
     他の変数を参照するようにすることもできます．
   */
  ptr = &v2;
  /*
    ptrが参照している変数が v2 に変わっていることを，
    v2の場所（アドレス）と，ptrの中身が同じであるということから確認しましょう．
  */
  printf ("v1@%p = %d, v2@%p = %d, ptr = %p\n", &v1, v1, &v2, v2, ptr);

  /*
    次の代入文は，「ptrが参照している変数に値を代入する」という意味では
    先ほどの代入文と同じです．しかしながら，先ほど  ptr が参照していたのは
    v1 であったのに対して，今は v2 を参照していますので，中身が変わるのは
    v2 の方です．v1 にはなんの影響もありません．
  */
  *ptr = 200;
  /* 
     v1 の値はそのままで，v2 の値が 200 に変わったことを確認しましょう
  */
  printf ("v1@%p = %d, v2@%p = %d, ptr = %p\n", &v1, v1, &v2, v2, ptr);

  return 0;
}
